import{a as l,t as i}from"../chunks/disclose-version.BMbhOq8Q.js";import"../chunks/legacy.B5UzwLvP.js";import{k as a,m as c,l as r,I as n}from"../chunks/runtime.CTT-Pcax.js";var d=i(`<article class="prose-gray prose-base text-white svelte-1brwwkm"><h1>Quick guide to writing FiTL queries</h1> <h2 class="svelte-1brwwkm">Simple Queries</h2> <p>At it's very root, FiTL filters down rows based on columns and conditional statements for
		described columns.</p> <p>Base form of a query can be described as:</p> <code class="svelte-1brwwkm">*column name* *operatorion* *comparison value*</code> <p>For example</p> <code class="svelte-1brwwkm">artist = JDilla</code> <p>Which in a playlist, returns a table where in all the rows the "artist" column is equal to
		"JDilla"</p> <p>You can inverse this statement by an "!", like:</p> <code class="svelte-1brwwkm">artist != JDilla</code> <p>or:</p> <code class="svelte-1brwwkm">! artist = JDilla</code> <p>Which filters out all the songs from a playlist where the "artist" column is equal to JDilla
		(idk why anyone would want to do that)</p> <h3 class="svelte-1brwwkm">Other common comparison values</h3> <p>Naturally comparisons are case case-insensitive. To make them case sensitive, add a "^" in front
		of the operation (but not before the negate value "!")</p> <code class="svelte-1brwwkm">artist ^= JDilla</code> <p>For a more rough estimate in string matching, you can do one of either two operations.</p> <p>The one that you'll probably be using the most often is the "contains" operation: "=:" which
		instead of checking for exact matches like the "=" operation, checks to see if the column in
		that specific row contains the comparitive value like such:</p> <code class="svelte-1brwwkm">artist =: dilla</code> <p>Tip: the colon is on the side of the smaller side</p> <p>The inverse of this is the "isin" operation: ":=". This checks to see if the comparison value
		contains the column value like such:</p> <code class="svelte-1brwwkm">artist := "JDilla and Slumvillage"</code> <h2 class="svelte-1brwwkm">Combining Queries together</h2> <p>You can combine multiple queries together with either a "&" (and) or an "|" (or) symble</p> <p>The "&" symbole is an "and" operation, meaning that both statements on each side of the "&" must
		be true in order for the query to pass for that row. For example:</p> <code class="svelte-1brwwkm">artist = "Michael Giacchino" & album =: soundtrack</code> <p>The above statement only returns rows where the artist name is "Michael Giacchino" AND the album
		title contains the word "soundtrack" in it.</p> <p>The "|" symbol is an "or" operation, meaning only one statement on each side of the "|" symbol
		have to be true in order for the query to pass for that row. For example:</p> <code class="svelte-1brwwkm">artist = "black thought" | artist =: roots</code> <p>The above statement returns rows where the artist is equal to "black thought" or the artist
		contains the string "roots" so we can filter through a playlist and get all of Black Thoughts
		solo catalog and also his catalog with The Roots.</p> <p>If you're really advanced (or you don't touch grass), you can get really specific and add
		parenthesis to your queries, which work exactly like they do in math</p> <code class="svelte-1brwwkm">(artist = "black thought" & album = "Streams of Thought Vol. 1") | artist =: roots</code> <p>This query returns any Roots song, or if it's a Black Thought song the album is only "Streams of
		Thought Vol. 1".</p> <p>Add as many and nest as many parenthesis as you want. Get crazy with it, I won't care but the
		compiler might yell at you.</p> <pre><code class="svelte-1brwwkm"></code></pre> <h1>Symbol Table</h1> <table class="svelte-1brwwkm"><thead><tr><th class="svelte-1brwwkm">Word</th><th class="svelte-1brwwkm">Symbol</th><th class="svelte-1brwwkm">Description</th></tr></thead><tbody><tr><td class="svelte-1brwwkm">not</td><td class="svelte-1brwwkm">!T</td><td class="svelte-1brwwkm">Negates Operation</td></tr><tr><td class="svelte-1brwwkm">is / equals</td><td class="svelte-1brwwkm">=</td><td class="svelte-1brwwkm">Exact match</td></tr><tr><td class="svelte-1brwwkm">contains</td><td class="svelte-1brwwkm">=:</td><td class="svelte-1brwwkm">Left contains right (Nickolas Picklous =: Nick)</td></tr><tr><td class="svelte-1brwwkm">isin</td><td class="svelte-1brwwkm">:=</td><td class="svelte-1brwwkm">Right contains left (Nick := Nickolas Picklous)</td></tr><tr><td class="svelte-1brwwkm">lessthan</td><td class="svelte-1brwwkm">&lt;</td><td class="svelte-1brwwkm">"Less than" comparison of numbers or characters based on ASCII value of characters</td></tr><tr><td class="svelte-1brwwkm">morethan</td><td class="svelte-1brwwkm">&gt;</td><td class="svelte-1brwwkm">"Greater than" comparison of numbers or characters based on ASCII value of characters</td></tr><tr><td class="svelte-1brwwkm">lessthanequals</td><td class="svelte-1brwwkm">&lt;=</td><td class="svelte-1brwwkm">"Less than or equals" comparison of numbers or characters based on ASCII value of
					characters</td></tr><tr><td class="svelte-1brwwkm">morethanequals</td><td class="svelte-1brwwkm">&gt;=</td><td class="svelte-1brwwkm">"Greater than or equals" comparison of numbers or characters based on ASCII value of
					characters</td></tr><tr><td class="svelte-1brwwkm">or</td><td class="svelte-1brwwkm">|</td><td class="svelte-1brwwkm">Or boolean operation</td></tr><tr><td class="svelte-1brwwkm">and</td><td class="svelte-1brwwkm">&amp;</td><td class="svelte-1brwwkm">And boolean operation</td></tr><tr><td class="svelte-1brwwkm"><em>Parenthesis</em></td><td class="svelte-1brwwkm">()</td><td class="svelte-1brwwkm">Prioritizes statements inside parenthesis</td></tr><tr><td class="svelte-1brwwkm"><em>NA</em></td><td class="svelte-1brwwkm">"&lt;value&gt;"</td><td class="svelte-1brwwkm">Combines multiple words into single string. Necessary for multi-worded tokens, optional
					for single-worded tokens</td></tr><tr><td class="svelte-1brwwkm"><em>NA</em></td><td class="svelte-1brwwkm">^T</td><td class="svelte-1brwwkm">Makes statement case-sensitive; queries are case-insensitive by default</td></tr></tbody></table></article>`);function h(t){var e=d(),s=c(a(e),68),o=a(s);o.textContent='((((((((((artist = "black thought" & album = "Streams of Thought Vol. 1")))))) | (((artist =: roots)))))',r(s),n(4),r(e),l(t,e)}function m(t){h(t)}export{m as component};
